-- Builds daily market data enriched with Russell 3000 attributes (incremental model).

{{ config(
    materialized = 'incremental',
    unique_key = ['ticker', 'trade_date'],
    on_schema_change = 'fail'
) }}

WITH russell_3000 AS (
    -- Time-aware dimension: defines when a ticker is considered part of the Russell 3000
    SELECT *
    FROM {{ ref('stg_russell3000__constituents') }}
),

full_market AS (
    -- Daily market fact data at ticker × trade_date grain
    SELECT DISTINCT *  -- DISTINCT used defensively to guard against upstream duplication
    FROM {{ ref('stg_daily_stocks') }}
    {% if is_incremental() %}
        -- On incremental runs, only reprocess recent days
        -- Handles late data, corrections, and retries
        WHERE trade_date >= (
            SELECT DATEADD(day, -4, MAX(trade_date))
            FROM {{ this }}
        )
    {% endif %}
),

joined AS (
    -- Enrich daily prices with Russell 3000 attributes
    -- Join is point-in-time correct using valid_from / valid_to
    SELECT 
        f.ticker,
        f.trade_date,
        f.volume,
        f.volume_weighted_avg,
        f.open,
        f.close,
        f.high,
        f.low,
        f.num_transactions,
        f.ingested_at,
        f.has_volume,
        f.is_valid_record,
        r.sector,
        r.company,
        r.market_weight AS index_weight
    FROM full_market AS f
    INNER JOIN russell_3000 AS r
        ON f.ticker = r.ticker
        AND f.trade_date BETWEEN r.valid_from AND r.valid_to
),

{% if is_incremental() %}
-- Pull historical rows from the already-built table
-- This lets today’s rows look back at yesterday even when yesterday is NOT in the current incremental slice
prev_day_close AS (
    SELECT
        ticker,
        trade_date,
        close AS prev_close
    FROM {{ this }}  -- the existing INT_RUSSELL3000__DAILY table
),
{% endif %}

final AS (
    SELECT
        j.*,

        -- Counts how many times this ticker has appeared since it last entered the index
        -- Resets only if the ticker disappears and later reappears
        ROW_NUMBER() OVER (
            PARTITION BY j.ticker
            ORDER BY j.trade_date
        ) AS consecutive_trading_days,

        {% if is_incremental() %}
        -- Get yesterday's close:
        -- 1) Use LAG if yesterday is in the current slice
        -- 2) Otherwise fall back to the historical table
        COALESCE(
            LAG(j.close) OVER (
                PARTITION BY j.ticker
                ORDER BY j.trade_date
            ),
            p.prev_close
        ) AS yesterday_close,
        {% else %}
        -- On full builds, all history is present
        -- LAG alone is sufficient
        LAG(j.close) OVER (
            PARTITION BY j.ticker
            ORDER BY j.trade_date
        ) AS yesterday_close,
        {% endif %}

        -- Flags the first day a ticker appears in the dataset
        -- If there is no previous row for this ticker, it is new
        CASE 
            WHEN LAG(j.ticker) OVER (
                PARTITION BY j.ticker
                ORDER BY j.trade_date
            ) IS NULL 
            THEN 1 
            ELSE 0 
        END AS is_new_to_index

    FROM joined AS j

    {% if is_incremental() %}
    -- Join today's row to yesterday's row from history
    -- Needed when yesterday is outside the incremental window
    LEFT JOIN prev_day_close AS p
        ON j.ticker = p.ticker
       AND j.trade_date = DATEADD(day, 1, p.trade_date)
    {% endif %}
)

SELECT * FROM final

////////////////////////////------------------------------------------------------------------------------------------

-- BASELINE VERSION (FULL RECOMPUTE)
-- Used only to measure non-incremental performance

{{ config(
    materialized = 'table',
    on_schema_change = 'fail'
) }}

WITH russell_3000 AS (
    -- Time-aware dimension: defines Russell 3000 membership by date
    SELECT *
    FROM {{ ref('stg_russell3000__constituents') }}
),

full_market AS (
    -- Full historical daily market data (no pruning)
    SELECT DISTINCT *
    FROM {{ ref('stg_daily_stocks') }}
),

joined AS (
    -- Point-in-time correct enrichment with index metadata
    SELECT 
        f.ticker,
        f.trade_date,
        f.volume,
        f.volume_weighted_avg,
        f.open,
        f.close,
        f.high,
        f.low,
        f.num_transactions,
        f.ingested_at,
        f.has_volume,
        f.is_valid_record,
        r.sector,
        r.company,
        r.market_weight AS index_weight
    FROM full_market AS f
    INNER JOIN russell_3000 AS r
        ON f.ticker = r.ticker
        AND f.trade_date BETWEEN r.valid_from AND r.valid_to
),

final AS (
    SELECT
        j.*,

        -- Count of appearances per ticker since first inclusion
        ROW_NUMBER() OVER (
            PARTITION BY j.ticker
            ORDER BY j.trade_date
        ) AS consecutive_trading_days,

        -- Previous trading day's close (all history available)
        LAG(j.close) OVER (
            PARTITION BY j.ticker
            ORDER BY j.trade_date
        ) AS yesterday_close,

        -- First appearance of ticker in the dataset
        CASE 
            WHEN LAG(j.ticker) OVER (
                PARTITION BY j.ticker
                ORDER BY j.trade_date
            ) IS NULL 
            THEN 1 
            ELSE 0 
        END AS is_new_to_index

    FROM joined AS j
)

SELECT * FROM final


